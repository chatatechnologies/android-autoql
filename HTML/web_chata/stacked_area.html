<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stacked Area</title>
  <script src="d3.v6.min.js"></script>
</head>
<body>
  <script>
  // Fake data
  const data = [
    {
      category: 'Barrel',
      alberta: 50,
      null: 100,
      British_Columbia: 300
    },
    {
      category: 'Hours',
      alberta: 150,
      null: 20,
      British_Columbia: 50
    },
    {
      category: 'Mile',
      alberta: 200,
      null: 90,
      British_Columbia: 100
    },
    {
      category: 'M3',
      alberta: 130,
      null: 90,
      British_Columbia: 50
    },
    {
      category: 'Day',
      alberta: 240,
      null: 10,
      British_Columbia: 80
    },
    {
      category: 'Each',
      alberta: 380,
      null: 100,
      British_Columbia: 10
    },
    {
      category: 'Month',
      alberta: 420,
      null: 10,
      British_Columbia: 200
    }
  ];
  const color = ["lightgreen", "cyan", "lightblue"];
  // Create SVG and padding for the chart
  const svg = d3
    .select('body').append('svg')
    .attr('height', 300)
    .attr('width', 600);

  const strokeWidth = 1.5;
  const margin = { top: 0, bottom: 20, left: 30, right: 20 };
  const chart = svg.append('g').attr('transform', `translate(${margin.left}, 0)`);

  const width = +svg.attr('width') - margin.left - margin.right - strokeWidth * 2;
  const height = +svg.attr('height') - margin.top - margin.bottom;
  const grp = chart
    .append('g')
    .attr('transform', `translate(-${margin.left - strokeWidth},-${margin.top})`);

  // Create stack
  const stack = d3.stack().keys(['alberta', 'null', 'British_Columbia']);
  const stackedValues = stack(data);
  const stackedData = [];
  // Copy the stack offsets back into the data.
  stackedValues.forEach((layer, index) => {
    const currentStack = [];
    layer.forEach((d, i) => {
      currentStack.push({
        values: d,
        category: data[i].category
      });
    });
    stackedData.push(currentStack);
  });

  // Create scales
  const yScale = d3
    .scaleLinear()
    .range([height, 0])
    .domain([
      0,
      d3.max(stackedValues[stackedValues.length - 1], dp => dp[1])]
    );
  const xScale = d3
    //use for to scale from start to final
    .scalePoint()
    .range([0, width])
    .domain(
      data.map(function(d) { return d.category; })
    )

  const area = d3
    .area()
    .x(dataPoint => {
      return xScale(dataPoint.category)
    })
    .y0(dataPoint => yScale(dataPoint.values[0]))
    .y1(dataPoint => yScale(dataPoint.values[1]));

  const series = grp
    .selectAll('.series')
    .data(stackedData)
    .enter()
    .append('g')
    .attr('class', 'series');

  series
    .append('path')
    .attr('transform', `translate(${margin.left},0)`)
    .style('fill', (_, i) => color[i])
    .attr('d', d => area(d));

  // Add the X Axis
  chart
    .append('g')
    .attr('transform', `translate(0,${height})`)
    .call(
      d3
      .axisBottom(xScale)
    );

  // Add the Y Axis
  chart
    .append('g')
    .attr('transform', `translate(0, 0)`)
    .call(d3.axisLeft(yScale));
  </script>
</body>
</html>